{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport ThemeSelector from '../components/mapcreatorcomponents/ThemeSelector.vue';\nimport OperationSelector from '../components/mapcreatorcomponents/OperationSelector.vue';\nimport RenderingScreen from \"@/components/mapcreatorcomponents/RenderingScreen.vue\";\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport axios from 'axios';\nconst brushSize = 25; // Eraser brush size\n\nexport default {\n  __name: 'MapCreator',\n  setup(__props, {\n    expose: __expose\n  }) {\n    __expose();\n    const activeTheme = ref('forest'); // Default theme\n    const cursorType = ref(''); // Default cursor type\n    const eraserActive = ref(false); // Track if eraser is being used\n    const isLoading = ref(false); // Add this reactive state to track loading\n    const brushColor = ref('#2e7d32'); // Make brushColor reactive\n    const obstructionIconPath = ref('/assets/tree_icon.svg'); // Default obstruction icon\n\n    const updateTheme = theme => {\n      activeTheme.value = theme;\n      if (theme === 'forest') {\n        brushColor.value = '#2e7d32';\n        obstructionIconPath.value = '/assets/tree_icon.svg';\n      } else if (theme === 'beach') {\n        brushColor.value = '#c68e17';\n        obstructionIconPath.value = '/assets/cactus_icon.svg';\n      } else {\n        brushColor.value = '#02f1fb';\n        obstructionIconPath.value = '/assets/snowman_icon.svg';\n      }\n      // Clear the canvas before recoloring\n      ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height);\n\n      // Recolor all stored areas with the new theme\n      storedGreenCoordinates.value.forEach(greenCoordinates => {\n        updateMapArea(greenCoordinates);\n      });\n    };\n    const updateCursor = type => {\n      cursorType.value = type;\n      let cursorUrl;\n      if (type === 'eraser') {\n        eraserActive.value = true; // Activate eraser\n      } else {\n        eraserActive.value = false; // Deactivate eraser\n      }\n      switch (type) {\n        case 'pen':\n          cursorUrl = '/assets/pen_icon_png.png';\n          break;\n        case 'eraser':\n          cursorUrl = '/assets/eraser_mouse_png.png'; // Weâ€™ll hide the default cursor\n          break;\n        case 'obstruction':\n        default:\n          cursorUrl = 'auto';\n      }\n      document.querySelector('.custom-cursor').style.cursor = `url(${cursorUrl}), auto`;\n    };\n    const canvasRef = ref(null);\n    let ctx = null;\n    let drawing = false;\n    let drawnPath = [];\n    const storedGreenCoordinates = ref([]); // Array to store all green areas\n    const imageArray = ref([]); // Array to store all images\n\n    const startDrawing = event => {\n      drawing = true;\n      drawnPath = []; // Clear previous path\n      ctx.beginPath(); // Start a new path\n      draw(event);\n    };\n    const stopDrawing = async () => {\n      if (!drawing) return;\n      drawing = false;\n      ctx.beginPath();\n      if (drawnPath.length > 0 && cursorType.value === 'pen') {\n        await sendToBackend(drawnPath); // Send path to backend after drawing\n      }\n    };\n    const draw = event => {\n      if (!drawing || cursorType.value === '' || cursorType.value === 'obstruction') return;\n      const rect = canvasRef.value.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n\n      // Store the current point in the path\n      drawnPath.push([x, y]);\n      ctx.lineWidth = cursorType.value === 'eraser' ? brushSize : 2;\n      ctx.lineCap = 'round';\n      ctx.strokeStyle = cursorType.value === 'eraser' ? '#f5f5dc' : brushColor.value;\n      if (cursorType.value === 'eraser') {\n        ctx.clearRect(x - brushSize / 2, y - brushSize / 2, brushSize, brushSize);\n      } else {\n        ctx.lineTo(x, y);\n        ctx.stroke();\n        // ctx.beginPath();\n        // ctx.moveTo(x, y);\n      }\n    };\n    const sendToBackend = async path => {\n      isLoading.value = true; // Show the loading popup\n      const canvas = canvasRef.value;\n      const bottomY = canvas.height;\n      try {\n        const response = await axios.post('http://localhost:8000/process-path', {\n          path,\n          bottomY\n        });\n        const result = response.data;\n\n        // Store the green coordinates\n        storedGreenCoordinates.value.push(result.greenCoordinates);\n\n        // Update the map with the new area\n        updateMapArea(result.greenCoordinates);\n      } catch (error) {\n        console.error('Error sending path to backend:', error);\n      } finally {\n        isLoading.value = false; // Hide the loading popup\n      }\n    };\n    const updateMapArea = greenCoordinates => {\n      ctx.beginPath();\n\n      // Set color based on active theme\n      ctx.strokeStyle = brushColor.value;\n      ctx.lineWidth = 2;\n      imageArray.value.forEach(({\n        x,\n        y,\n        desiredWidth,\n        desiredHeight\n      }) => {\n        const img = new Image();\n        img.src = obstructionIconPath.value;\n        img.onload = () => {\n          ctx.drawImage(img, x - desiredWidth / 2, y - desiredHeight / 2, desiredWidth, desiredHeight);\n        };\n      });\n      greenCoordinates.forEach(([x, y]) => {\n        ctx.lineTo(x, y);\n      });\n      ctx.stroke();\n    };\n    const updateBrushCircle = event => {\n      if (!eraserActive.value) return;\n      const brushCircle = document.querySelector('.brush-circle');\n      brushCircle.style.display = 'block';\n      brushCircle.style.left = `${event.clientX - brushSize / 2}px`;\n      brushCircle.style.top = `${event.clientY - brushSize / 2}px`;\n    };\n    const hideBrushCircle = () => {\n      document.querySelector('.brush-circle').style.display = 'none';\n    };\n    onMounted(() => {\n      const canvas = canvasRef.value;\n      ctx = canvas.getContext('2d', {\n        willReadFrequently: true\n      });\n      document.addEventListener('mousedown', startDrawing);\n      document.addEventListener('mouseup', stopDrawing);\n      document.addEventListener('mousemove', event => {\n        draw(event);\n        updateBrushCircle(event); // Update circle position while moving\n      });\n      canvas.addEventListener('mouseleave', hideBrushCircle); // Hide circle when mouse leaves canvas\n    });\n    onBeforeUnmount(() => {\n      document.removeEventListener('mousedown', startDrawing);\n      document.removeEventListener('mouseup', stopDrawing);\n      document.removeEventListener('mousemove', draw);\n    });\n    const onDrop = event => {\n      event.preventDefault();\n      console.log('onDrop event triggered');\n\n      // Get the drop coordinates\n      const rect = canvasRef.value.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      console.log(`Drop coordinates: x=${x}, y=${y}`);\n\n      // Get the dragged image URL\n      const imgUrl = obstructionIconPath.value;\n      console.log(`Image URL: ${imgUrl}`);\n\n      // Create a new image element to draw on the canvas\n      const img = new Image();\n      img.src = imgUrl;\n      img.crossOrigin = 'anonymous'; // Enable CORS for the image\n      img.onload = () => {\n        const desiredWidth = 29; // Set the desired width\n        const desiredHeight = 37; // Set the desired height\n        console.log('Image loaded, starting animation');\n        animateImage(img, x, y, desiredWidth, desiredHeight);\n      };\n    };\n    const animateImage = (img, startX, startY, width, height) => {\n      let y = startY;\n      const gravity = 1; // Gravity effect\n\n      const step = () => {\n        ctx.clearRect(startX - width / 2, y - height / 2, width, height); // Clear previous image position\n\n        // Check for collision with any non-transparent color\n        const imageData = ctx.getImageData(startX, y + height / 2, width, 1).data;\n        console.log('Image data:', imageData);\n        let collision = false;\n\n        // Check if all pixels in the row are transparent\n        for (let i = 3; i < imageData.length; i += 4) {\n          // Iterate over alpha values\n          console.log('Alpha value:', imageData[i]);\n          console.log(\"r value:\", imageData[i - 3]);\n          console.log(\"g value:\", imageData[i - 2]);\n          console.log(\"b value:\", imageData[i - 1]);\n          if (imageData[i] > 30) {\n            // Check for non-transparent pixel\n            console.log('Collision detected');\n            collision = true;\n            break;\n          }\n        }\n        if (!collision) {\n          y += gravity; // Apply gravity\n          ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at new position\n          requestAnimationFrame(step); // Continue animation\n        } else {\n          ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at final position\n          imageArray.value.push({\n            x: startX,\n            y,\n            desiredWidth: width,\n            desiredHeight: height\n          }); // Store final position\n          storedGreenCoordinates.value.forEach(greenCoordinates => {\n            updateMapArea(greenCoordinates);\n          });\n        }\n      };\n      step(); // Start the animation\n    };\n    const __returned__ = {\n      activeTheme,\n      cursorType,\n      eraserActive,\n      isLoading,\n      brushSize,\n      brushColor,\n      obstructionIconPath,\n      updateTheme,\n      updateCursor,\n      canvasRef,\n      get ctx() {\n        return ctx;\n      },\n      set ctx(v) {\n        ctx = v;\n      },\n      get drawing() {\n        return drawing;\n      },\n      set drawing(v) {\n        drawing = v;\n      },\n      get drawnPath() {\n        return drawnPath;\n      },\n      set drawnPath(v) {\n        drawnPath = v;\n      },\n      storedGreenCoordinates,\n      imageArray,\n      startDrawing,\n      stopDrawing,\n      draw,\n      sendToBackend,\n      updateMapArea,\n      updateBrushCircle,\n      hideBrushCircle,\n      onDrop,\n      animateImage,\n      ThemeSelector,\n      OperationSelector,\n      RenderingScreen,\n      ref,\n      onMounted,\n      onBeforeUnmount,\n      get axios() {\n        return axios;\n      }\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n};","map":{"version":3,"names":["ThemeSelector","OperationSelector","RenderingScreen","ref","onMounted","onBeforeUnmount","axios","brushSize","activeTheme","cursorType","eraserActive","isLoading","brushColor","obstructionIconPath","updateTheme","theme","value","ctx","clearRect","canvasRef","width","height","storedGreenCoordinates","forEach","greenCoordinates","updateMapArea","updateCursor","type","cursorUrl","document","querySelector","style","cursor","drawing","drawnPath","imageArray","startDrawing","event","beginPath","draw","stopDrawing","length","sendToBackend","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","push","lineWidth","lineCap","strokeStyle","lineTo","stroke","path","canvas","bottomY","response","post","result","data","error","console","desiredWidth","desiredHeight","img","Image","src","onload","drawImage","updateBrushCircle","brushCircle","display","hideBrushCircle","getContext","willReadFrequently","addEventListener","removeEventListener","onDrop","preventDefault","log","imgUrl","crossOrigin","animateImage","startX","startY","gravity","step","imageData","getImageData","collision","i","requestAnimationFrame"],"sources":["/home/antiphy/ITU/ITU_project/src/views/MapCreator.vue"],"sourcesContent":["<script setup>\nimport ThemeSelector from '../components/mapcreatorcomponents/ThemeSelector.vue';\nimport OperationSelector from '../components/mapcreatorcomponents/OperationSelector.vue';\nimport RenderingScreen from \"@/components/mapcreatorcomponents/RenderingScreen.vue\";\n\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport axios from 'axios';\n\nconst activeTheme = ref('forest'); // Default theme\nconst cursorType = ref(''); // Default cursor type\nconst eraserActive = ref(false); // Track if eraser is being used\nconst isLoading = ref(false); // Add this reactive state to track loading\nconst brushSize = 25; // Eraser brush size\nconst brushColor = ref('#2e7d32'); // Make brushColor reactive\nconst obstructionIconPath = ref('/assets/tree_icon.svg'); // Default obstruction icon\n\nconst updateTheme = (theme) => {\n  activeTheme.value = theme;\n  if (theme === 'forest') {\n    brushColor.value = '#2e7d32';\n    obstructionIconPath.value = '/assets/tree_icon.svg';\n  } else if (theme === 'beach') {\n    brushColor.value = '#c68e17';\n    obstructionIconPath.value = '/assets/cactus_icon.svg';\n  } else {\n    brushColor.value = '#02f1fb';\n    obstructionIconPath.value = '/assets/snowman_icon.svg';\n  }\n  // Clear the canvas before recoloring\n  ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height);\n\n  // Recolor all stored areas with the new theme\n  storedGreenCoordinates.value.forEach(greenCoordinates => {\n    updateMapArea(greenCoordinates);\n  });\n};\n\nconst updateCursor = (type) => {\n  cursorType.value = type;\n  let cursorUrl;\n  if (type === 'eraser') {\n    eraserActive.value = true; // Activate eraser\n  } else {\n    eraserActive.value = false; // Deactivate eraser\n  }\n\n  switch (type) {\n    case 'pen':\n      cursorUrl = '/assets/pen_icon_png.png';\n      break;\n    case 'eraser':\n      cursorUrl = '/assets/eraser_mouse_png.png'; // Weâ€™ll hide the default cursor\n      break;\n    case 'obstruction':\n    default:\n      cursorUrl = 'auto';\n  }\n  document.querySelector('.custom-cursor').style.cursor = `url(${cursorUrl}), auto`;\n};\n\nconst canvasRef = ref(null);\nlet ctx = null;\nlet drawing = false;\nlet drawnPath = [];\nconst storedGreenCoordinates = ref([]);  // Array to store all green areas\nconst imageArray = ref([]);  // Array to store all images\n\nconst startDrawing = (event) => {\n  drawing = true;\n  drawnPath = [];  // Clear previous path\n  ctx.beginPath();  // Start a new path\n  draw(event);\n};\n\nconst stopDrawing = async () => {\n  if (!drawing) return;\n  drawing = false;\n  ctx.beginPath();\n  if (drawnPath.length > 0 && cursorType.value === 'pen') {\n    await sendToBackend(drawnPath);  // Send path to backend after drawing\n  }\n};\n\nconst draw = (event) => {\n  if (!drawing || cursorType.value === '' || cursorType.value === 'obstruction') return;\n\n  const rect = canvasRef.value.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n\n  // Store the current point in the path\n  drawnPath.push([x, y]);\n\n  ctx.lineWidth = cursorType.value === 'eraser' ? brushSize : 2;\n  ctx.lineCap = 'round';\n  ctx.strokeStyle = cursorType.value === 'eraser' ? '#f5f5dc' : brushColor.value;\n\n  if (cursorType.value === 'eraser') {\n    ctx.clearRect(x - brushSize / 2, y - brushSize / 2, brushSize, brushSize);\n  } else {\n    ctx.lineTo(x, y);\n    ctx.stroke();\n    // ctx.beginPath();\n    // ctx.moveTo(x, y);\n  }\n};\n\nconst sendToBackend = async (path) => {\n  isLoading.value = true;  // Show the loading popup\n  const canvas = canvasRef.value;\n  const bottomY = canvas.height;\n\n  try {\n    const response = await axios.post('http://localhost:8000/process-path', {\n      path,\n      bottomY\n    });\n    const result = response.data;\n\n    // Store the green coordinates\n    storedGreenCoordinates.value.push(result.greenCoordinates);\n\n    // Update the map with the new area\n    updateMapArea(result.greenCoordinates);\n  } catch (error) {\n    console.error('Error sending path to backend:', error);\n  } finally {\n    isLoading.value = false;  // Hide the loading popup\n  }\n};\n\nconst updateMapArea = (greenCoordinates) => {\n  ctx.beginPath();\n\n  // Set color based on active theme\n  ctx.strokeStyle = brushColor.value;\n  ctx.lineWidth = 2;\n\n  imageArray.value.forEach(({ x, y, desiredWidth, desiredHeight }) => {\n    const img = new Image();\n    img.src = obstructionIconPath.value;\n    img.onload = () => {\n      ctx.drawImage(img, x - desiredWidth / 2, y - desiredHeight / 2, desiredWidth, desiredHeight);\n    };\n  });\n\n  greenCoordinates.forEach(([x, y]) => {\n    ctx.lineTo(x, y);\n  });\n\n  ctx.stroke();\n};\n\nconst updateBrushCircle = (event) => {\n  if (!eraserActive.value) return;\n\n  const brushCircle = document.querySelector('.brush-circle');\n  brushCircle.style.display = 'block';\n  brushCircle.style.left = `${event.clientX - brushSize / 2}px`;\n  brushCircle.style.top = `${event.clientY - brushSize / 2}px`;\n};\n\nconst hideBrushCircle = () => {\n  document.querySelector('.brush-circle').style.display = 'none';\n};\n\nonMounted(() => {\n  const canvas = canvasRef.value;\n  ctx = canvas.getContext('2d', { willReadFrequently: true });\n\n  document.addEventListener('mousedown', startDrawing);\n  document.addEventListener('mouseup', stopDrawing);\n  document.addEventListener('mousemove', (event) => {\n    draw(event);\n    updateBrushCircle(event); // Update circle position while moving\n  });\n  canvas.addEventListener('mouseleave', hideBrushCircle); // Hide circle when mouse leaves canvas\n});\n\nonBeforeUnmount(() => {\n  document.removeEventListener('mousedown', startDrawing);\n  document.removeEventListener('mouseup', stopDrawing);\n  document.removeEventListener('mousemove', draw);\n});\n\nconst onDrop = (event) => {\n  event.preventDefault();\n  console.log('onDrop event triggered');\n\n  // Get the drop coordinates\n  const rect = canvasRef.value.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n  console.log(`Drop coordinates: x=${x}, y=${y}`);\n\n  // Get the dragged image URL\n  const imgUrl = obstructionIconPath.value;\n  console.log(`Image URL: ${imgUrl}`);\n\n  // Create a new image element to draw on the canvas\n  const img = new Image();\n  img.src = imgUrl;\n  img.crossOrigin = 'anonymous'; // Enable CORS for the image\n  img.onload = () => {\n    const desiredWidth = 29; // Set the desired width\n    const desiredHeight = 37; // Set the desired height\n    console.log('Image loaded, starting animation');\n    animateImage(img, x, y, desiredWidth, desiredHeight);\n  };\n};\n\nconst animateImage = (img, startX, startY, width, height) => {\n  let y = startY;\n  const gravity = 1; // Gravity effect\n\n  const step = () => {\n    ctx.clearRect(startX - width / 2, y - height / 2, width, height); // Clear previous image position\n\n    // Check for collision with any non-transparent color\n    const imageData = ctx.getImageData(startX, y + height / 2, width, 1).data;\n    console.log('Image data:', imageData);\n    let collision = false;\n\n    // Check if all pixels in the row are transparent\n    for (let i = 3; i < imageData.length; i += 4) { // Iterate over alpha values\n      console.log('Alpha value:', imageData[i]);\n      console.log(\"r value:\", imageData[i-3]);\n      console.log(\"g value:\", imageData[i-2]);\n      console.log(\"b value:\", imageData[i-1]);\n      if (imageData[i] > 30) { // Check for non-transparent pixel\n        console.log('Collision detected');\n        collision = true;\n        break;\n      }\n    }\n\n    if (!collision) {\n      y += gravity; // Apply gravity\n      ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at new position\n      requestAnimationFrame(step); // Continue animation\n    } else {\n      ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at final position\n      imageArray.value.push({ x: startX, y, desiredWidth: width, desiredHeight: height }); // Store final position\n      storedGreenCoordinates.value.forEach(greenCoordinates => {\n        updateMapArea(greenCoordinates);\n      });\n    }\n  };\n\n  step(); // Start the animation\n};\n\n</script>\n\n<template>\n  <div class=\"min-h-screen bg-beige flex flex-col justify-center items-center relative custom-cursor\">\n    <div class=\"canvas-container\">\n      <ThemeSelector :activeTheme=\"activeTheme\" @theme-change=\"updateTheme\" class=\"theme-selector\"/>\n      <OperationSelector :activeTheme=\"activeTheme\" @cursor-change=\"updateCursor\" class=\"operation-selector\"/>\n      <canvas ref=\"canvasRef\" width=\"900\" height=\"500\" class=\"border-2 border-black mt-4\"\n              @dragover.prevent\n              @drop=\"onDrop\"\n      ></canvas>\n    </div>\n    <div class=\"brush-circle\"></div>\n    <RenderingScreen :visible=\"isLoading\" message=\"Rendering...\" />\n  </div>\n</template>\n\n<style scoped>\n\n.extra-margin {\n  margin-top: 10px; /* Adjust the value as needed */\n}\n\n.bg-beige {\n  background-color: #f5f5dc; /* Beige color */\n}\n\n.canvas-container {\n  position: relative;\n  display: inline-block;\n  margin-top: 50px; /* Adjust the value as needed */\n\n}\n\n.theme-selector {\n  position: absolute;\n  top: -90px; /* Adjust as needed */\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.operation-selector {\n  position: absolute;\n  top: 40%;\n  right: -140px; /* Adjust as needed */\n  transform: translateY(-50%);\n}\n.brush-circle {\n  position: absolute;\n  width: 25px; /* Match the brush size */\n  height: 25px;\n  border-radius: 50%;\n  background-color: rgba(41, 220, 70, 0.3); /* Red color with transparency */\n  box-shadow: 0 0 10px rgba(78, 238, 61, 0.7); /* Glowing red shadow */\n  pointer-events: none; /* Ensure the circle doesnâ€™t interfere with events */\n  display: none; /* Hidden until the eraser is active */\n}\n</style>\n"],"mappings":";AACA,OAAOA,aAAa,MAAM,sDAAsD;AAChF,OAAOC,iBAAiB,MAAM,0DAA0D;AACxF,OAAOC,eAAe,MAAM,uDAAuD;AAEnF,SAASC,GAAG,EAAEC,SAAS,EAAEC,eAAe,QAAQ,KAAK;AACrD,OAAOC,KAAK,MAAM,OAAO;AAMzB,MAAMC,SAAS,GAAG,EAAE,CAAC,CAAC;;;;;;;;IAJtB,MAAMC,WAAW,GAAGL,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;IACnC,MAAMM,UAAU,GAAGN,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5B,MAAMO,YAAY,GAAGP,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;IACjC,MAAMQ,SAAS,GAAGR,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;IAE9B,MAAMS,UAAU,GAAGT,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;IACnC,MAAMU,mBAAmB,GAAGV,GAAG,CAAC,uBAAuB,CAAC,CAAC,CAAC;;IAE1D,MAAMW,WAAW,GAAIC,KAAK,IAAK;MAC7BP,WAAW,CAACQ,KAAK,GAAGD,KAAK;MACzB,IAAIA,KAAK,KAAK,QAAQ,EAAE;QACtBH,UAAU,CAACI,KAAK,GAAG,SAAS;QAC5BH,mBAAmB,CAACG,KAAK,GAAG,uBAAuB;MACrD,CAAC,MAAM,IAAID,KAAK,KAAK,OAAO,EAAE;QAC5BH,UAAU,CAACI,KAAK,GAAG,SAAS;QAC5BH,mBAAmB,CAACG,KAAK,GAAG,yBAAyB;MACvD,CAAC,MAAM;QACLJ,UAAU,CAACI,KAAK,GAAG,SAAS;QAC5BH,mBAAmB,CAACG,KAAK,GAAG,0BAA0B;MACxD;MACA;MACAC,GAAG,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEC,SAAS,CAACH,KAAK,CAACI,KAAK,EAAED,SAAS,CAACH,KAAK,CAACK,MAAM,CAAC;;MAElE;MACAC,sBAAsB,CAACN,KAAK,CAACO,OAAO,CAACC,gBAAgB,IAAI;QACvDC,aAAa,CAACD,gBAAgB,CAAC;MACjC,CAAC,CAAC;IACJ,CAAC;IAED,MAAME,YAAY,GAAIC,IAAI,IAAK;MAC7BlB,UAAU,CAACO,KAAK,GAAGW,IAAI;MACvB,IAAIC,SAAS;MACb,IAAID,IAAI,KAAK,QAAQ,EAAE;QACrBjB,YAAY,CAACM,KAAK,GAAG,IAAI,CAAC,CAAC;MAC7B,CAAC,MAAM;QACLN,YAAY,CAACM,KAAK,GAAG,KAAK,CAAC,CAAC;MAC9B;MAEA,QAAQW,IAAI;QACV,KAAK,KAAK;UACRC,SAAS,GAAG,0BAA0B;UACtC;QACF,KAAK,QAAQ;UACXA,SAAS,GAAG,8BAA8B,CAAC,CAAC;UAC5C;QACF,KAAK,aAAa;QAClB;UACEA,SAAS,GAAG,MAAM;MACtB;MACAC,QAAQ,CAACC,aAAa,CAAC,gBAAgB,CAAC,CAACC,KAAK,CAACC,MAAM,GAAG,OAAOJ,SAAS,SAAS;IACnF,CAAC;IAED,MAAMT,SAAS,GAAGhB,GAAG,CAAC,IAAI,CAAC;IAC3B,IAAIc,GAAG,GAAG,IAAI;IACd,IAAIgB,OAAO,GAAG,KAAK;IACnB,IAAIC,SAAS,GAAG,EAAE;IAClB,MAAMZ,sBAAsB,GAAGnB,GAAG,CAAC,EAAE,CAAC,CAAC,CAAE;IACzC,MAAMgC,UAAU,GAAGhC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAE;;IAE7B,MAAMiC,YAAY,GAAIC,KAAK,IAAK;MAC9BJ,OAAO,GAAG,IAAI;MACdC,SAAS,GAAG,EAAE,CAAC,CAAE;MACjBjB,GAAG,CAACqB,SAAS,CAAC,CAAC,CAAC,CAAE;MAClBC,IAAI,CAACF,KAAK,CAAC;IACb,CAAC;IAED,MAAMG,WAAW,GAAG,MAAAA,CAAA,KAAY;MAC9B,IAAI,CAACP,OAAO,EAAE;MACdA,OAAO,GAAG,KAAK;MACfhB,GAAG,CAACqB,SAAS,CAAC,CAAC;MACf,IAAIJ,SAAS,CAACO,MAAM,GAAG,CAAC,IAAIhC,UAAU,CAACO,KAAK,KAAK,KAAK,EAAE;QACtD,MAAM0B,aAAa,CAACR,SAAS,CAAC,CAAC,CAAE;MACnC;IACF,CAAC;IAED,MAAMK,IAAI,GAAIF,KAAK,IAAK;MACtB,IAAI,CAACJ,OAAO,IAAIxB,UAAU,CAACO,KAAK,KAAK,EAAE,IAAIP,UAAU,CAACO,KAAK,KAAK,aAAa,EAAE;MAE/E,MAAM2B,IAAI,GAAGxB,SAAS,CAACH,KAAK,CAAC4B,qBAAqB,CAAC,CAAC;MACpD,MAAMC,CAAC,GAAGR,KAAK,CAACS,OAAO,GAAGH,IAAI,CAACI,IAAI;MACnC,MAAMC,CAAC,GAAGX,KAAK,CAACY,OAAO,GAAGN,IAAI,CAACO,GAAG;;MAElC;MACAhB,SAAS,CAACiB,IAAI,CAAC,CAACN,CAAC,EAAEG,CAAC,CAAC,CAAC;MAEtB/B,GAAG,CAACmC,SAAS,GAAG3C,UAAU,CAACO,KAAK,KAAK,QAAQ,GAAGT,SAAS,GAAG,CAAC;MAC7DU,GAAG,CAACoC,OAAO,GAAG,OAAO;MACrBpC,GAAG,CAACqC,WAAW,GAAG7C,UAAU,CAACO,KAAK,KAAK,QAAQ,GAAG,SAAS,GAAGJ,UAAU,CAACI,KAAK;MAE9E,IAAIP,UAAU,CAACO,KAAK,KAAK,QAAQ,EAAE;QACjCC,GAAG,CAACC,SAAS,CAAC2B,CAAC,GAAGtC,SAAS,GAAG,CAAC,EAAEyC,CAAC,GAAGzC,SAAS,GAAG,CAAC,EAAEA,SAAS,EAAEA,SAAS,CAAC;MAC3E,CAAC,MAAM;QACLU,GAAG,CAACsC,MAAM,CAACV,CAAC,EAAEG,CAAC,CAAC;QAChB/B,GAAG,CAACuC,MAAM,CAAC,CAAC;QACZ;QACA;MACF;IACF,CAAC;IAED,MAAMd,aAAa,GAAG,MAAOe,IAAI,IAAK;MACpC9C,SAAS,CAACK,KAAK,GAAG,IAAI,CAAC,CAAE;MACzB,MAAM0C,MAAM,GAAGvC,SAAS,CAACH,KAAK;MAC9B,MAAM2C,OAAO,GAAGD,MAAM,CAACrC,MAAM;MAE7B,IAAI;QACF,MAAMuC,QAAQ,GAAG,MAAMtD,KAAK,CAACuD,IAAI,CAAC,oCAAoC,EAAE;UACtEJ,IAAI;UACJE;QACF,CAAC,CAAC;QACF,MAAMG,MAAM,GAAGF,QAAQ,CAACG,IAAI;;QAE5B;QACAzC,sBAAsB,CAACN,KAAK,CAACmC,IAAI,CAACW,MAAM,CAACtC,gBAAgB,CAAC;;QAE1D;QACAC,aAAa,CAACqC,MAAM,CAACtC,gBAAgB,CAAC;MACxC,CAAC,CAAC,OAAOwC,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MACxD,CAAC,SAAS;QACRrD,SAAS,CAACK,KAAK,GAAG,KAAK,CAAC,CAAE;MAC5B;IACF,CAAC;IAED,MAAMS,aAAa,GAAID,gBAAgB,IAAK;MAC1CP,GAAG,CAACqB,SAAS,CAAC,CAAC;;MAEf;MACArB,GAAG,CAACqC,WAAW,GAAG1C,UAAU,CAACI,KAAK;MAClCC,GAAG,CAACmC,SAAS,GAAG,CAAC;MAEjBjB,UAAU,CAACnB,KAAK,CAACO,OAAO,CAAC,CAAC;QAAEsB,CAAC;QAAEG,CAAC;QAAEkB,YAAY;QAAEC;MAAc,CAAC,KAAK;QAClE,MAAMC,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;QACvBD,GAAG,CAACE,GAAG,GAAGzD,mBAAmB,CAACG,KAAK;QACnCoD,GAAG,CAACG,MAAM,GAAG,MAAM;UACjBtD,GAAG,CAACuD,SAAS,CAACJ,GAAG,EAAEvB,CAAC,GAAGqB,YAAY,GAAG,CAAC,EAAElB,CAAC,GAAGmB,aAAa,GAAG,CAAC,EAAED,YAAY,EAAEC,aAAa,CAAC;QAC9F,CAAC;MACH,CAAC,CAAC;MAEF3C,gBAAgB,CAACD,OAAO,CAAC,CAAC,CAACsB,CAAC,EAAEG,CAAC,CAAC,KAAK;QACnC/B,GAAG,CAACsC,MAAM,CAACV,CAAC,EAAEG,CAAC,CAAC;MAClB,CAAC,CAAC;MAEF/B,GAAG,CAACuC,MAAM,CAAC,CAAC;IACd,CAAC;IAED,MAAMiB,iBAAiB,GAAIpC,KAAK,IAAK;MACnC,IAAI,CAAC3B,YAAY,CAACM,KAAK,EAAE;MAEzB,MAAM0D,WAAW,GAAG7C,QAAQ,CAACC,aAAa,CAAC,eAAe,CAAC;MAC3D4C,WAAW,CAAC3C,KAAK,CAAC4C,OAAO,GAAG,OAAO;MACnCD,WAAW,CAAC3C,KAAK,CAACgB,IAAI,GAAG,GAAGV,KAAK,CAACS,OAAO,GAAGvC,SAAS,GAAG,CAAC,IAAI;MAC7DmE,WAAW,CAAC3C,KAAK,CAACmB,GAAG,GAAG,GAAGb,KAAK,CAACY,OAAO,GAAG1C,SAAS,GAAG,CAAC,IAAI;IAC9D,CAAC;IAED,MAAMqE,eAAe,GAAGA,CAAA,KAAM;MAC5B/C,QAAQ,CAACC,aAAa,CAAC,eAAe,CAAC,CAACC,KAAK,CAAC4C,OAAO,GAAG,MAAM;IAChE,CAAC;IAEDvE,SAAS,CAAC,MAAM;MACd,MAAMsD,MAAM,GAAGvC,SAAS,CAACH,KAAK;MAC9BC,GAAG,GAAGyC,MAAM,CAACmB,UAAU,CAAC,IAAI,EAAE;QAAEC,kBAAkB,EAAE;MAAK,CAAC,CAAC;MAE3DjD,QAAQ,CAACkD,gBAAgB,CAAC,WAAW,EAAE3C,YAAY,CAAC;MACpDP,QAAQ,CAACkD,gBAAgB,CAAC,SAAS,EAAEvC,WAAW,CAAC;MACjDX,QAAQ,CAACkD,gBAAgB,CAAC,WAAW,EAAG1C,KAAK,IAAK;QAChDE,IAAI,CAACF,KAAK,CAAC;QACXoC,iBAAiB,CAACpC,KAAK,CAAC,CAAC,CAAC;MAC5B,CAAC,CAAC;MACFqB,MAAM,CAACqB,gBAAgB,CAAC,YAAY,EAAEH,eAAe,CAAC,CAAC,CAAC;IAC1D,CAAC,CAAC;IAEFvE,eAAe,CAAC,MAAM;MACpBwB,QAAQ,CAACmD,mBAAmB,CAAC,WAAW,EAAE5C,YAAY,CAAC;MACvDP,QAAQ,CAACmD,mBAAmB,CAAC,SAAS,EAAExC,WAAW,CAAC;MACpDX,QAAQ,CAACmD,mBAAmB,CAAC,WAAW,EAAEzC,IAAI,CAAC;IACjD,CAAC,CAAC;IAEF,MAAM0C,MAAM,GAAI5C,KAAK,IAAK;MACxBA,KAAK,CAAC6C,cAAc,CAAC,CAAC;MACtBjB,OAAO,CAACkB,GAAG,CAAC,wBAAwB,CAAC;;MAErC;MACA,MAAMxC,IAAI,GAAGxB,SAAS,CAACH,KAAK,CAAC4B,qBAAqB,CAAC,CAAC;MACpD,MAAMC,CAAC,GAAGR,KAAK,CAACS,OAAO,GAAGH,IAAI,CAACI,IAAI;MACnC,MAAMC,CAAC,GAAGX,KAAK,CAACY,OAAO,GAAGN,IAAI,CAACO,GAAG;MAClCe,OAAO,CAACkB,GAAG,CAAC,uBAAuBtC,CAAC,OAAOG,CAAC,EAAE,CAAC;;MAE/C;MACA,MAAMoC,MAAM,GAAGvE,mBAAmB,CAACG,KAAK;MACxCiD,OAAO,CAACkB,GAAG,CAAC,cAAcC,MAAM,EAAE,CAAC;;MAEnC;MACA,MAAMhB,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;MACvBD,GAAG,CAACE,GAAG,GAAGc,MAAM;MAChBhB,GAAG,CAACiB,WAAW,GAAG,WAAW,CAAC,CAAC;MAC/BjB,GAAG,CAACG,MAAM,GAAG,MAAM;QACjB,MAAML,YAAY,GAAG,EAAE,CAAC,CAAC;QACzB,MAAMC,aAAa,GAAG,EAAE,CAAC,CAAC;QAC1BF,OAAO,CAACkB,GAAG,CAAC,kCAAkC,CAAC;QAC/CG,YAAY,CAAClB,GAAG,EAAEvB,CAAC,EAAEG,CAAC,EAAEkB,YAAY,EAAEC,aAAa,CAAC;MACtD,CAAC;IACH,CAAC;IAED,MAAMmB,YAAY,GAAGA,CAAClB,GAAG,EAAEmB,MAAM,EAAEC,MAAM,EAAEpE,KAAK,EAAEC,MAAM,KAAK;MAC3D,IAAI2B,CAAC,GAAGwC,MAAM;MACd,MAAMC,OAAO,GAAG,CAAC,CAAC,CAAC;;MAEnB,MAAMC,IAAI,GAAGA,CAAA,KAAM;QACjBzE,GAAG,CAACC,SAAS,CAACqE,MAAM,GAAGnE,KAAK,GAAG,CAAC,EAAE4B,CAAC,GAAG3B,MAAM,GAAG,CAAC,EAAED,KAAK,EAAEC,MAAM,CAAC,CAAC,CAAC;;QAElE;QACA,MAAMsE,SAAS,GAAG1E,GAAG,CAAC2E,YAAY,CAACL,MAAM,EAAEvC,CAAC,GAAG3B,MAAM,GAAG,CAAC,EAAED,KAAK,EAAE,CAAC,CAAC,CAAC2C,IAAI;QACzEE,OAAO,CAACkB,GAAG,CAAC,aAAa,EAAEQ,SAAS,CAAC;QACrC,IAAIE,SAAS,GAAG,KAAK;;QAErB;QACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAAClD,MAAM,EAAEqD,CAAC,IAAI,CAAC,EAAE;UAAE;UAC9C7B,OAAO,CAACkB,GAAG,CAAC,cAAc,EAAEQ,SAAS,CAACG,CAAC,CAAC,CAAC;UACzC7B,OAAO,CAACkB,GAAG,CAAC,UAAU,EAAEQ,SAAS,CAACG,CAAC,GAAC,CAAC,CAAC,CAAC;UACvC7B,OAAO,CAACkB,GAAG,CAAC,UAAU,EAAEQ,SAAS,CAACG,CAAC,GAAC,CAAC,CAAC,CAAC;UACvC7B,OAAO,CAACkB,GAAG,CAAC,UAAU,EAAEQ,SAAS,CAACG,CAAC,GAAC,CAAC,CAAC,CAAC;UACvC,IAAIH,SAAS,CAACG,CAAC,CAAC,GAAG,EAAE,EAAE;YAAE;YACvB7B,OAAO,CAACkB,GAAG,CAAC,oBAAoB,CAAC;YACjCU,SAAS,GAAG,IAAI;YAChB;UACF;QACF;QAEA,IAAI,CAACA,SAAS,EAAE;UACd7C,CAAC,IAAIyC,OAAO,CAAC,CAAC;UACdxE,GAAG,CAACuD,SAAS,CAACJ,GAAG,EAAEmB,MAAM,GAAGnE,KAAK,GAAG,CAAC,EAAE4B,CAAC,GAAG3B,MAAM,GAAG,CAAC,EAAED,KAAK,EAAEC,MAAM,CAAC,CAAC,CAAC;UACvE0E,qBAAqB,CAACL,IAAI,CAAC,CAAC,CAAC;QAC/B,CAAC,MAAM;UACLzE,GAAG,CAACuD,SAAS,CAACJ,GAAG,EAAEmB,MAAM,GAAGnE,KAAK,GAAG,CAAC,EAAE4B,CAAC,GAAG3B,MAAM,GAAG,CAAC,EAAED,KAAK,EAAEC,MAAM,CAAC,CAAC,CAAC;UACvEc,UAAU,CAACnB,KAAK,CAACmC,IAAI,CAAC;YAAEN,CAAC,EAAE0C,MAAM;YAAEvC,CAAC;YAAEkB,YAAY,EAAE9C,KAAK;YAAE+C,aAAa,EAAE9C;UAAO,CAAC,CAAC,CAAC,CAAC;UACrFC,sBAAsB,CAACN,KAAK,CAACO,OAAO,CAACC,gBAAgB,IAAI;YACvDC,aAAa,CAACD,gBAAgB,CAAC;UACjC,CAAC,CAAC;QACJ;MACF,CAAC;MAEDkE,IAAI,CAAC,CAAC,CAAC,CAAC;IACV,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}