{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, vModelText as _vModelText, withDirectives as _withDirectives, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"game-page text-center mt-20\"\n};\nconst _hoisted_2 = {\n  class: \"block\"\n};\nconst _hoisted_3 = {\n  class: \"font-bold\"\n};\nconst _hoisted_4 = {\n  class: \"text-2xl\"\n};\nconst _hoisted_5 = [\"width\", \"height\"];\nconst _hoisted_6 = {\n  class: \"controls mt-4 flex justify-center items-center gap-4\"\n};\nconst _hoisted_7 = {\n  class: \"block font-bold\"\n};\nconst _hoisted_8 = {\n  class: \"block font-bold\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_cache[5] || (_cache[5] = _createElementVNode(\"h1\", {\n    class: \"text-2xl font-bold mb-4\"\n  }, \"Tanks\", -1 /* HOISTED */)), _createElementVNode(\"label\", _hoisted_2, [_createElementVNode(\"span\", _hoisted_3, [_cache[3] || (_cache[3] = _createTextVNode(\"Wind: \")), _createElementVNode(\"span\", _hoisted_4, _toDisplayString($data.wind), 1 /* TEXT */)]), _cache[4] || (_cache[4] = _createTextVNode(\" (positive for right, negative for left)\"))]), _createElementVNode(\"canvas\", {\n    ref: \"gameCanvas\",\n    width: $data.canvasWidth,\n    height: $data.canvasHeight,\n    class: \"border border-gray-700 m-auto\"\n  }, null, 8 /* PROPS */, _hoisted_5), _createElementVNode(\"div\", _hoisted_6, [_createElementVNode(\"div\", null, [_createElementVNode(\"label\", _hoisted_7, \"Angle: \" + _toDisplayString($data.angle) + \"Â°\", 1 /* TEXT */), _withDirectives(_createElementVNode(\"input\", {\n    type: \"range\",\n    min: \"0\",\n    max: \"90\",\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => $data.angle = $event),\n    class: \"w-32\"\n  }, null, 512 /* NEED_PATCH */), [[_vModelText, $data.angle]])]), _createElementVNode(\"div\", null, [_createElementVNode(\"label\", _hoisted_8, \"Power: \" + _toDisplayString($data.power), 1 /* TEXT */), _withDirectives(_createElementVNode(\"input\", {\n    type: \"range\",\n    min: \"10\",\n    max: \"100\",\n    \"onUpdate:modelValue\": _cache[1] || (_cache[1] = $event => $data.power = $event),\n    class: \"w-32\"\n  }, null, 512 /* NEED_PATCH */), [[_vModelText, $data.power]])]), _createElementVNode(\"button\", {\n    onClick: _cache[2] || (_cache[2] = (...args) => $options.fireMissile && $options.fireMissile(...args)),\n    class: \"px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n  }, \" Fire \")])]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_hoisted_3","_createTextVNode","_hoisted_4","_toDisplayString","$data","wind","ref","width","canvasWidth","height","canvasHeight","_hoisted_5","_hoisted_6","_hoisted_7","angle","type","min","max","_cache","$event","_hoisted_8","power","onClick","args","$options","fireMissile"],"sources":["/home/antiphy/ITU/ITU_project/src/views/GameScreen.vue"],"sourcesContent":["<!-- <template>\n\n    <div class=\"flex justify-center items-center min-h-screen bg-grey-300\">\n        <div style=\"margin-top: 180px;\">\n            <canvas id=\"gameCanvas\" :width=\"canvasWidth\" :height=\"canvasHeight\" class=\"flex justify-end\"></canvas>\n        </div>\n    </div>\n\n\n  </template>\n  \n  <script>\n  export default {\n    name: 'GameScreen',\n    data() {\n      return {\n        canvasWidth: 1920,  // Width of the canvas\n        canvasHeight: 900, // Height of the canvas\n        map: [], // 2D Array for the terrain\n        tank: null,\n        tankX: 100, // Initial X position of the tank\n        tankY: 505, // Initial Y position of the tank\n      };\n    },\n    mounted() {\n        this.initializeMap();\n        this.loadTankImage();\n        window.addEventListener('keydown', this.handleKeyDown); // Listen for keydown events\n    },\n    beforeUnmount() {\n        window.removeEventListener('keydown', this.handleKeyDown); // Clean up the event listener\n    },\n    methods: {\n        loadTankImage() {\n            this.tankImage = new Image();\n            this.tankImage.src = '/assets/tank.png'; // Replace with your SVG path\n\n            // Wait for the image to load before drawing the map\n            this.tankImage.onload = () => {\n                this.drawMap(); // Draw the map after the tank image has loaded\n            };\n        },\n\n        // Initialize the map with ground and sky\n        initializeMap() {\n            const groundLevel = 550; // Set ground level in pixels\n            \n            // Create a 2D array (matrix) representing the map\n            this.map = Array(this.canvasHeight).fill().map((_, y) => \n                Array(this.canvasWidth).fill().map(() => (y >= groundLevel ? 1 : 0))\n            );\n        },\n\n\n    // Draw the map using canvas\n        drawMap() {\n            const canvas = document.getElementById('gameCanvas');\n            const ctx = canvas.getContext('2d');\n            \n            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n            // Loop through the map array and draw each pixel\n            for (let y = 0; y < this.map.length; y++) {\n                for (let x = 0; x < this.map[y].length; x++) {\n                    ctx.fillStyle = this.map[y][x] === 1 ? 'green': 'skyblue'; // Set color based on terrain\n                    ctx.fillRect(x, y, 1, 1); // Draw each pixel/block\n                }\n            }\n\n            ctx.drawImage(this.tankImage, this.tankX, this.tankY, 75, 45); // Adjust width and height as needed\n        },\n\n        handleKeyDown(event) {\n            const step = 10; // Number of pixels to move the tank\n\n            switch (event.key) {\n                case 'ArrowLeft':\n                    this.tankX -= step; // Move left\n                    break;\n                case 'ArrowRight':\n                    this.tankX += step; // Move right\n                    break;\n            }\n\n            // Ensure the tank stays within the canvas boundaries\n            if (this.tankX < 0) this.tankX = 0; // Prevent moving out of bounds to the left\n            if (this.tankX > this.canvasWidth - 50) this.tankX = this.canvasWidth - 50; // Prevent moving out of bounds to the right\n\n            this.drawMap(); // Redraw the map with the updated tank position\n        },\n    }\n  };\n  </script>\n  \n  <style scoped>\n\n    .row {\n    display: flex;\n    }\n\n    .pixel {\n    width: 1px;\n    height: 1px;\n    }\n</style> -->\n\n<!-- <template>\n    <div class=\"flex justify-center items-center min-h-screen bg-grey-300\">\n        <div style=\"margin-top: 180px;\">\n            <canvas id=\"gameCanvas\" :width=\"canvasWidth\" :height=\"canvasHeight\" class=\"flex justify-end\"></canvas>\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: 'GameScreen',\n    data() {\n        return {\n            canvasWidth: 1920,  // Width of the canvas\n            canvasHeight: 900, // Height of the canvas\n            map: [], // 2D Array for the terrain\n            tankImage: null, // To store the loaded tank image\n            tankX: 100, // Initial X position of the tank\n            tankY: 505, // Initial Y position of the tank\n            moveLeft: false, // Flag for moving left\n            moveRight: false, // Flag for moving right\n            gameLoop: null, // Reference to the game loop\n            step: 20, // Number of pixels to move the tank each frame\n        };\n    },\n    mounted() {\n        this.loadTankImage(); // Load the tank image\n        this.initializeMap();\n        window.addEventListener('keydown', this.handleKeyDown); // Listen for keydown events\n        window.addEventListener('keyup', this.handleKeyUp); // Listen for keyup events\n        this.startLoop(); // Start the game loop\n    },\n    beforeUnmount() {\n        window.removeEventListener('keydown', this.handleKeyDown); // Clean up the event listener\n        window.removeEventListener('keyup', this.handleKeyUp); // Clean up the event listener\n        clearInterval(this.intervalId); // Stop the movement loop\n    },\n    methods: {\n        loadTankImage() {\n            this.tankImage = new Image();\n            this.tankImage.src = 'assets/tank.png'; // Replace with your SVG path\n\n            // Wait for the image to load before drawing the map\n            this.tankImage.onload = () => {\n                this.drawMap(); // Draw the map after the tank image has loaded\n            };\n        },\n\n        initializeMap() {\n            const groundLevel = 550; // Set ground level in pixels\n            \n            // Create a 2D array (matrix) representing the map\n            this.map = Array(this.canvasHeight).fill().map((_, y) => \n                Array(this.canvasWidth).fill().map(() => (y >= groundLevel ? 1 : 0))\n            );\n        },\n\n        drawMap() {\n            const canvas = document.getElementById('gameCanvas');\n            const ctx = canvas.getContext('2d');\n            \n            // Clear the canvas\n            ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n            // Loop through the map array and draw each pixel\n            for (let y = 0; y < this.map.length; y++) {\n                for (let x = 0; x < this.map[y].length; x++) {\n                    ctx.fillStyle = this.map[y][x] === 1 ? 'green' : 'skyblue'; // Set color based on terrain\n                    ctx.fillRect(x, y, 1, 1); // Draw each pixel/block\n                }\n            }\n\n            // Draw the tank at its current position\n            ctx.drawImage(this.tankImage, this.tankX, this.tankY, 75, 45); // Adjust width and height as needed\n        },\n\n        handleKeyDown(event) {\n            switch (event.key) {\n                case 'ArrowLeft':\n                    this.moveLeft = true; // Set flag to move left\n                    break;\n                case 'ArrowRight':\n                    this.moveRight = true; // Set flag to move right\n                    break;\n            }\n        },\n\n        handleKeyUp(event) {\n            switch (event.key) {\n                case 'ArrowLeft':\n                    this.moveLeft = false; // Clear flag to stop moving left\n                    break;\n                case 'ArrowRight':\n                    this.moveRight = false; // Clear flag to stop moving right\n                    break;\n            }\n        },\n\n        startMovementLoop() {\n            this.intervalId = setInterval(() => {\n                // Check movement flags and update tank position\n                if (this.moveLeft) {\n                    this.tankX -= this.step; // Move left\n                }\n                if (this.moveRight) {\n                    this.tankX += this.step; // Move right\n                }\n\n                // Ensure the tank stays within the canvas boundaries\n                if (this.tankX < 0) this.tankX = 0; // Prevent moving out of bounds to the left\n                if (this.tankX > this.canvasWidth - 50) this.tankX = this.canvasWidth - 50; // Prevent moving out of bounds to the right\n\n                this.drawMap(); // Redraw the map with the updated tank position\n            }, 16); // Adjust this value for smoother or slower movement (16 ms ~ 60 FPS)\n        },\n    }\n};\n</script>\n\n<style scoped>\n.row {\n    display: flex;\n}\n.pixel {\n    width: 10px;\n    height: 10px;\n}\n</style> -->\n\n<template>\n    <div class=\"game-page text-center mt-20\">\n      <h1 class=\"text-2xl font-bold mb-4\">Tanks</h1>\n      <label class=\"block\"><span class=\"font-bold\">Wind: <span class=\"text-2xl\">{{ wind }}</span> </span>  (positive for right, negative for left)</label>\n      <canvas \n        ref=\"gameCanvas\" \n        :width=\"canvasWidth\" \n        :height=\"canvasHeight\" \n        class=\"border border-gray-700 m-auto\"\n      ></canvas>\n      <div class=\"controls mt-4 flex justify-center items-center gap-4\">\n        <div>\n          <label class=\"block font-bold\">Angle: {{ angle }}Â°</label>\n          <input \n            type=\"range\" \n            min=\"0\" \n            max=\"90\" \n            v-model=\"angle\" \n            class=\"w-32\"\n          />\n        </div>\n        <div>\n          <label class=\"block font-bold\">Power: {{ power }}</label>\n          <input \n            type=\"range\" \n            min=\"10\" \n            max=\"100\" \n            v-model=\"power\" \n            class=\"w-32\"\n          />\n        </div>\n        <button \n          @click=\"fireMissile\" \n          class=\"px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n        >\n          Fire\n        </button>\n      </div>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: \"GamePage\",\n    data() {\n      return {\n        canvasWidth: 1000,\n        canvasHeight: 600,\n        terrain: [],\n        player1: {\n          x: 100,\n          y: 370,\n          size: 40,\n          angle: 45,\n          power: 50,\n          tankColor: \"green\",\n        },\n        wind: 0,\n        missile: null,\n        angle: 45,\n        power: 50,\n        gameOver: false,\n      };\n    },\n    mounted() {\n      this.wind = Math.floor(Math.random() * 100 - 50); \n      this.player1.tankColor = this.$route.query.color;\n      this.generateTerrain();\n      this.renderGame();\n    },\n    methods: {\n      generateTerrain() {\n        // Generate a simple random terrain\n        this.terrain = new Array(this.canvasWidth).fill(0).map((_, x) => {\n          const baseHeight = this.canvasHeight - 200;\n          const variation = Math.sin(x * 0.06) * 15;\n          return baseHeight + variation;\n        });\n      },\n      fireMissile() {\n        const startX = this.player1.x + 15;\n        const startY = this.player1.y - 15; //this.terrain[Math.floor(player.x)] - player.size / 2\n        const controlX = startX + Math.cos(this.angle * (Math.PI / 180)) * this.power * 5 + this.wind * 4;\n        const controlY = startY - Math.sin(this.angle * (Math.PI / 180)) * this.power * 5;\n        const endX = controlX + Math.cos(this.angle * (Math.PI / 180)) * this.power * 5 + this.wind * 8;\n        const endY = this.canvasHeight;\n  \n        this.missile = {\n          t: 0,\n          startX,\n          startY,\n          controlX,\n          controlY,\n          endX,\n          endY,\n        };\n  \n        this.animateMissile();\n      },\n      animateMissile() {\n        if (!this.missile) return;\n  \n        const { t, startX, startY, controlX, controlY, endX, endY } = this.missile;\n  \n        const x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * controlX + t * t * endX;\n        const y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * controlY + t * t * endY;\n  \n        this.missile.t += 0.01;\n        if (this.missile.t >= 1 || this.checkTerrainCollision(x, y)) {\n          this.explodeTerrain(x, y);\n          this.missile = null;\n          this.gameOver = true;\n          return;\n        }\n  \n        this.renderGame();\n  \n        const canvas = this.$refs.gameCanvas;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.beginPath();\n        ctx.arc(x, y, 5, 0, 2 * Math.PI);\n        ctx.fillStyle = \"red\";\n        ctx.fill();\n  \n        requestAnimationFrame(this.animateMissile);\n      },\n      checkTerrainCollision(x, y) {\n        // Check if the missile hit the terrain\n        return y >= this.terrain[Math.floor(x)];\n      },\n      explodeTerrain(x, y) {\n        // Create a circular explosion in the terrain\n        const explosionRadius = 20;\n        for (let i = -explosionRadius; i <= explosionRadius; i++) {\n          const pos = Math.floor(x) + i;\n          if (pos >= 0 && pos < this.canvasWidth) {\n            const distance = Math.sqrt(i * i);\n            if (distance <= explosionRadius) {\n              const impactDepth = Math.sqrt(explosionRadius * explosionRadius - distance * distance);\n              this.terrain[pos] = Math.max(this.terrain[pos], y + impactDepth);\n            }\n          }\n        }\n        this.renderGame();\n        this.wind = Math.floor(Math.random() * 100 - 50); \n\n      },\n      renderGame() {\n        const canvas = this.$refs.gameCanvas;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n  \n        // Draw the terrain\n        this.drawTerrain(ctx);\n  \n        // Draw player 1's tank\n        this.drawTank(ctx, this.player1);\n      },\n      drawTerrain(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(0, this.canvasHeight);\n        for (let x = 0; x < this.terrain.length; x++) {\n          ctx.lineTo(x, this.terrain[x]);\n        }\n        ctx.lineTo(this.canvasWidth, this.canvasHeight);\n        ctx.closePath();\n        ctx.fillStyle = \"saddlebrown\";\n        ctx.fill();\n      },\n      drawTank(ctx, player) {\n        ctx.save();\n        ctx.translate(player.x, this.terrain[Math.floor(player.x)] - player.size / 2);\n  \n        // Draw the tank body\n        ctx.fillStyle = this.player1.tankColor;\n        ctx.fillRect(-player.size / 2, -player.size / 4, player.size, player.size / 2);\n  \n        // Draw the tank turret\n        const turretLength = player.size * 0.7;\n        ctx.translate(0, -player.size / 7);\n        ctx.rotate((-this.angle * Math.PI) / 180);\n        ctx.fillStyle = this.player1.tankColor;\n        ctx.fillRect(0, -5, turretLength, 10);\n  \n        ctx.restore();\n      },\n    },\n  };\n  </script>\n"],"mappings":";;EA4OSA,KAAK,EAAC;AAA6B;;EAE/BA,KAAK,EAAC;AAAO;;EAAOA,KAAK,EAAC;AAAW;;EAAaA,KAAK,EAAC;AAAU;mBA9O/E;;EAqPWA,KAAK,EAAC;AAAsD;;EAEtDA,KAAK,EAAC;AAAiB;;EAUvBA,KAAK,EAAC;AAAiB;;uBArBpCC,mBAAA,CAqCM,OArCNC,UAqCM,G,0BApCJC,mBAAA,CAA8C;IAA1CH,KAAK,EAAC;EAAyB,GAAC,OAAK,sBACzCG,mBAAA,CAAoJ,SAApJC,UAAoJ,GAA/HD,mBAAA,CAA8E,QAA9EE,UAA8E,G,0BA9OzGC,gBAAA,CA8OmD,QAAM,IAAAH,mBAAA,CAAwC,QAAxCI,UAAwC,EAAAC,gBAAA,CAAdC,KAAA,CAAAC,IAAI,iB,6BA9OvFJ,gBAAA,CA8OyG,0CAAyC,G,GAC5IH,mBAAA,CAKU;IAJRQ,GAAG,EAAC,YAAY;IACfC,KAAK,EAAEH,KAAA,CAAAI,WAAW;IAClBC,MAAM,EAAEL,KAAA,CAAAM,YAAY;IACrBf,KAAK,EAAC;0BAnPdgB,UAAA,GAqPMb,mBAAA,CA2BM,OA3BNc,UA2BM,GA1BJd,mBAAA,CASM,cARJA,mBAAA,CAA2D,SAA3De,UAA2D,EAA5B,SAAO,GAAAV,gBAAA,CAAGC,KAAA,CAAAU,KAAK,IAAG,IAAE,iB,gBACnDhB,mBAAA,CAME;IALAiB,IAAI,EAAC,OAAO;IACZC,GAAG,EAAC,GAAG;IACPC,GAAG,EAAC,IAAI;IA3PpB,uBAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IA4PqBf,KAAA,CAAAU,KAAK,GAAAK,MAAA;IACdxB,KAAK,EAAC;iDADGS,KAAA,CAAAU,KAAK,E,KAIlBhB,mBAAA,CASM,cARJA,mBAAA,CAAyD,SAAzDsB,UAAyD,EAA1B,SAAO,GAAAjB,gBAAA,CAAGC,KAAA,CAAAiB,KAAK,kB,gBAC9CvB,mBAAA,CAME;IALAiB,IAAI,EAAC,OAAO;IACZC,GAAG,EAAC,IAAI;IACRC,GAAG,EAAC,KAAK;IArQrB,uBAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAsQqBf,KAAA,CAAAiB,KAAK,GAAAF,MAAA;IACdxB,KAAK,EAAC;iDADGS,KAAA,CAAAiB,KAAK,E,KAIlBvB,mBAAA,CAKS;IAJNwB,OAAK,EAAAJ,MAAA,QAAAA,MAAA,UAAAK,IAAA,KAAEC,QAAA,CAAAC,WAAA,IAAAD,QAAA,CAAAC,WAAA,IAAAF,IAAA,CAAW;IACnB5B,KAAK,EAAC;KACP,QAED,E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}