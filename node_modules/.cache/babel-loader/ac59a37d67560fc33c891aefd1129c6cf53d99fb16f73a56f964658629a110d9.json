{"ast":null,"code":"import { createVNode as _createVNode, withModifiers as _withModifiers, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"min-h-screen bg-beige flex flex-col justify-center items-center relative custom-cursor\"\n};\nconst _hoisted_2 = {\n  class: \"canvas-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [_createVNode($setup[\"ThemeSelector\"], {\n    activeTheme: $setup.activeTheme,\n    onThemeChange: $setup.updateTheme,\n    class: \"theme-selector\"\n  }, null, 8 /* PROPS */, [\"activeTheme\"]), _createVNode($setup[\"OperationSelector\"], {\n    activeTheme: $setup.activeTheme,\n    onCursorChange: $setup.updateCursor,\n    class: \"operation-selector\"\n  }, null, 8 /* PROPS */, [\"activeTheme\"]), _createElementVNode(\"canvas\", {\n    ref: \"canvasRef\",\n    width: \"900\",\n    height: \"500\",\n    class: \"border-2 border-black mt-4\",\n    onDragover: _cache[0] || (_cache[0] = _withModifiers(() => {}, [\"prevent\"])),\n    onDrop: $setup.onDrop\n  }, null, 544 /* NEED_HYDRATION, NEED_PATCH */)]), _cache[1] || (_cache[1] = _createElementVNode(\"div\", {\n    class: \"brush-circle\"\n  }, null, -1 /* HOISTED */)), _createVNode($setup[\"RenderingScreen\"], {\n    visible: $setup.isLoading,\n    message: \"Rendering...\"\n  }, null, 8 /* PROPS */, [\"visible\"])]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_createVNode","$setup","activeTheme","onThemeChange","updateTheme","onCursorChange","updateCursor","ref","width","height","onDragover","_cache","_withModifiers","onDrop","visible","isLoading","message"],"sources":["/home/antiphy/ITU/ITU_project/src/views/MapCreator.vue"],"sourcesContent":["<script setup>\nimport ThemeSelector from '../components/mapcreatorcomponents/ThemeSelector.vue';\nimport OperationSelector from '../components/mapcreatorcomponents/OperationSelector.vue';\nimport RenderingScreen from \"@/components/mapcreatorcomponents/RenderingScreen.vue\";\n\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport axios from 'axios';\n\nconst activeTheme = ref('forest'); // Default theme\nconst cursorType = ref(''); // Default cursor type\nconst eraserActive = ref(false); // Track if eraser is being used\nconst isLoading = ref(false); // Add this reactive state to track loading\nconst brushSize = 25; // Eraser brush size\nconst brushColor = ref('#2e7d32'); // Make brushColor reactive\nconst obstructionIconPath = ref('/assets/tree_icon.svg'); // Default obstruction icon\n\nconst updateTheme = (theme) => {\n  activeTheme.value = theme;\n  if (theme === 'forest') {\n    brushColor.value = '#2e7d32';\n    obstructionIconPath.value = '/assets/tree_icon.svg';\n  } else if (theme === 'beach') {\n    brushColor.value = '#c68e17';\n    obstructionIconPath.value = '/assets/cactus_icon.svg';\n  } else {\n    brushColor.value = '#02f1fb';\n    obstructionIconPath.value = '/assets/snowman_icon.svg';\n  }\n  // Clear the canvas before recoloring\n  ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height);\n\n  // Recolor all stored areas with the new theme\n  storedGreenCoordinates.value.forEach(greenCoordinates => {\n    updateMapArea(greenCoordinates);\n  });\n};\n\nconst updateCursor = (type) => {\n  cursorType.value = type;\n  let cursorUrl;\n  if (type === 'eraser') {\n    eraserActive.value = true; // Activate eraser\n  } else {\n    eraserActive.value = false; // Deactivate eraser\n  }\n\n  switch (type) {\n    case 'pen':\n      cursorUrl = '/assets/pen_icon_png.png';\n      break;\n    case 'eraser':\n      cursorUrl = '/assets/eraser_mouse_png.png'; // We’ll hide the default cursor\n      break;\n    case 'obstruction':\n    default:\n      cursorUrl = 'auto';\n  }\n  document.querySelector('.custom-cursor').style.cursor = `url(${cursorUrl}), auto`;\n};\n\nconst canvasRef = ref(null);\nlet ctx = null;\nlet drawing = false;\nlet drawnPath = [];\nconst storedGreenCoordinates = ref([]);  // Array to store all green areas\nconst imageArray = ref([]);  // Array to store all images\n\nconst startDrawing = (event) => {\n  drawing = true;\n  drawnPath = [];  // Clear previous path\n  ctx.beginPath();  // Start a new path\n  draw(event);\n};\n\nconst stopDrawing = async () => {\n  if (!drawing) return;\n  drawing = false;\n  ctx.beginPath();\n  if (drawnPath.length > 0 && cursorType.value === 'pen') {\n    await sendToBackend(drawnPath);  // Send path to backend after drawing\n  }\n};\n\nconst draw = (event) => {\n  if (!drawing || cursorType.value === '' || cursorType.value === 'obstruction') return;\n\n  const rect = canvasRef.value.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n\n  // Store the current point in the path\n  drawnPath.push([x, y]);\n\n  ctx.lineWidth = cursorType.value === 'eraser' ? brushSize : 2;\n  ctx.lineCap = 'round';\n  ctx.strokeStyle = cursorType.value === 'eraser' ? '#f5f5dc' : brushColor.value;\n\n  if (cursorType.value === 'eraser') {\n    ctx.clearRect(x - brushSize / 2, y - brushSize / 2, brushSize, brushSize);\n  } else {\n    ctx.lineTo(x, y);\n    ctx.stroke();\n    // ctx.beginPath();\n    // ctx.moveTo(x, y);\n  }\n};\n\nconst sendToBackend = async (path) => {\n  isLoading.value = true;  // Show the loading popup\n  const canvas = canvasRef.value;\n  const bottomY = canvas.height;\n\n  try {\n    const response = await axios.post('http://localhost:8000/process-path', {\n      path,\n      bottomY\n    });\n    const result = response.data;\n\n    // Store the green coordinates\n    storedGreenCoordinates.value.push(result.greenCoordinates);\n\n    // Update the map with the new area\n    updateMapArea(result.greenCoordinates);\n  } catch (error) {\n    console.error('Error sending path to backend:', error);\n  } finally {\n    isLoading.value = false;  // Hide the loading popup\n  }\n};\n\nconst updateMapArea = (greenCoordinates) => {\n  ctx.beginPath();\n\n  // Set color based on active theme\n  ctx.strokeStyle = brushColor.value;\n  ctx.lineWidth = 2;\n\n  imageArray.value.forEach(({ x, y, desiredWidth, desiredHeight }) => {\n    const img = new Image();\n    img.src = obstructionIconPath.value;\n    img.onload = () => {\n      ctx.drawImage(img, x - desiredWidth / 2, y - desiredHeight / 2, desiredWidth, desiredHeight);\n    };\n  });\n\n  greenCoordinates.forEach(([x, y]) => {\n    ctx.lineTo(x, y);\n  });\n\n  ctx.stroke();\n};\n\nconst updateBrushCircle = (event) => {\n  if (!eraserActive.value) return;\n\n  const brushCircle = document.querySelector('.brush-circle');\n  brushCircle.style.display = 'block';\n  brushCircle.style.left = `${event.clientX - brushSize / 2}px`;\n  brushCircle.style.top = `${event.clientY - brushSize / 2}px`;\n};\n\nconst hideBrushCircle = () => {\n  document.querySelector('.brush-circle').style.display = 'none';\n};\n\nonMounted(() => {\n  const canvas = canvasRef.value;\n  ctx = canvas.getContext('2d', { willReadFrequently: true });\n\n  document.addEventListener('mousedown', startDrawing);\n  document.addEventListener('mouseup', stopDrawing);\n  document.addEventListener('mousemove', (event) => {\n    draw(event);\n    updateBrushCircle(event); // Update circle position while moving\n  });\n  canvas.addEventListener('mouseleave', hideBrushCircle); // Hide circle when mouse leaves canvas\n});\n\nonBeforeUnmount(() => {\n  document.removeEventListener('mousedown', startDrawing);\n  document.removeEventListener('mouseup', stopDrawing);\n  document.removeEventListener('mousemove', draw);\n});\n\nconst onDrop = (event) => {\n  event.preventDefault();\n  console.log('onDrop event triggered');\n\n  // Get the drop coordinates\n  const rect = canvasRef.value.getBoundingClientRect();\n  const x = event.clientX - rect.left;\n  const y = event.clientY - rect.top;\n  console.log(`Drop coordinates: x=${x}, y=${y}`);\n\n  // Get the dragged image URL\n  const imgUrl = obstructionIconPath.value;\n  console.log(`Image URL: ${imgUrl}`);\n\n  // Create a new image element to draw on the canvas\n  const img = new Image();\n  img.src = imgUrl;\n  img.crossOrigin = 'anonymous'; // Enable CORS for the image\n  img.onload = () => {\n    const desiredWidth = 29; // Set the desired width\n    const desiredHeight = 37; // Set the desired height\n    console.log('Image loaded, starting animation');\n    animateImage(img, x, y, desiredWidth, desiredHeight);\n  };\n};\n\nconst animateImage = (img, startX, startY, width, height) => {\n  let y = startY;\n  const gravity = 1; // Gravity effect\n\n  const step = () => {\n    ctx.clearRect(startX - width / 2, y - height / 2, width, height); // Clear previous image position\n\n    // Check for collision with any non-transparent color\n    const imageData = ctx.getImageData(startX, y + height / 2, width, 1).data;\n    console.log('Image data:', imageData);\n    let collision = false;\n\n    // Check if all pixels in the row are transparent\n    for (let i = 3; i < imageData.length; i += 4) { // Iterate over alpha values\n      console.log('Alpha value:', imageData[i]);\n      console.log(\"r value:\", imageData[i-3]);\n      console.log(\"g value:\", imageData[i-2]);\n      console.log(\"b value:\", imageData[i-1]);\n      if (imageData[i] > 30) { // Check for non-transparent pixel\n        console.log('Collision detected');\n        collision = true;\n        break;\n      }\n    }\n\n    if (!collision) {\n      y += gravity; // Apply gravity\n      ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at new position\n      requestAnimationFrame(step); // Continue animation\n    } else {\n      ctx.drawImage(img, startX - width / 2, y - height / 2, width, height); // Draw image at final position\n      imageArray.value.push({ x: startX, y, desiredWidth: width, desiredHeight: height }); // Store final position\n      storedGreenCoordinates.value.forEach(greenCoordinates => {\n        updateMapArea(greenCoordinates);\n      });\n    }\n  };\n\n  step(); // Start the animation\n};\n\n</script>\n\n<template>\n  <div class=\"min-h-screen bg-beige flex flex-col justify-center items-center relative custom-cursor\">\n    <div class=\"canvas-container\">\n      <ThemeSelector :activeTheme=\"activeTheme\" @theme-change=\"updateTheme\" class=\"theme-selector\"/>\n      <OperationSelector :activeTheme=\"activeTheme\" @cursor-change=\"updateCursor\" class=\"operation-selector\"/>\n      <canvas ref=\"canvasRef\" width=\"900\" height=\"500\" class=\"border-2 border-black mt-4\"\n              @dragover.prevent\n              @drop=\"onDrop\"\n      ></canvas>\n    </div>\n    <div class=\"brush-circle\"></div>\n    <RenderingScreen :visible=\"isLoading\" message=\"Rendering...\" />\n  </div>\n</template>\n\n<style scoped>\n\n.extra-margin {\n  margin-top: 10px; /* Adjust the value as needed */\n}\n\n.bg-beige {\n  background-color: #f5f5dc; /* Beige color */\n}\n\n.canvas-container {\n  position: relative;\n  display: inline-block;\n  margin-top: 50px; /* Adjust the value as needed */\n\n}\n\n.theme-selector {\n  position: absolute;\n  top: -90px; /* Adjust as needed */\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.operation-selector {\n  position: absolute;\n  top: 40%;\n  right: -140px; /* Adjust as needed */\n  transform: translateY(-50%);\n}\n.brush-circle {\n  position: absolute;\n  width: 25px; /* Match the brush size */\n  height: 25px;\n  border-radius: 50%;\n  background-color: rgba(41, 220, 70, 0.3); /* Red color with transparency */\n  box-shadow: 0 0 10px rgba(78, 238, 61, 0.7); /* Glowing red shadow */\n  pointer-events: none; /* Ensure the circle doesn’t interfere with events */\n  display: none; /* Hidden until the eraser is active */\n}\n</style>\n"],"mappings":";;EA+POA,KAAK,EAAC;AAAwF;;EAC5FA,KAAK,EAAC;AAAkB;;uBAD/BC,mBAAA,CAWM,OAXNC,UAWM,GAVJC,mBAAA,CAOM,OAPNC,UAOM,GANJC,YAAA,CAA8FC,MAAA;IAA9EC,WAAW,EAAED,MAAA,CAAAC,WAAW;IAAGC,aAAY,EAAEF,MAAA,CAAAG,WAAW;IAAET,KAAK,EAAC;4CAC5EK,YAAA,CAAwGC,MAAA;IAApFC,WAAW,EAAED,MAAA,CAAAC,WAAW;IAAGG,cAAa,EAAEJ,MAAA,CAAAK,YAAY;IAAEX,KAAK,EAAC;4CAClFG,mBAAA,CAGU;IAHFS,GAAG,EAAC,WAAW;IAACC,KAAK,EAAC,KAAK;IAACC,MAAM,EAAC,KAAK;IAACd,KAAK,EAAC,4BAA4B;IAC1Ee,UAAQ,EAAAC,MAAA,QAAAA,MAAA,MApQvBC,cAAA,CAoQc,QAAiB;IAChBC,MAAI,EAAEZ,MAAA,CAAAY;8EAGjBf,mBAAA,CAAgC;IAA3BH,KAAK,EAAC;EAAc,6BACzBK,YAAA,CAA+DC,MAAA;IAA7Ca,OAAO,EAAEb,MAAA,CAAAc,SAAS;IAAEC,OAAO,EAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}