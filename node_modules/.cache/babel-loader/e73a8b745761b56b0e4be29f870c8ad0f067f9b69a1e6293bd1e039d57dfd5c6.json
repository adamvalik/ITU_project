{"ast":null,"code":"export default {\n  name: 'GameScreen',\n  data() {\n    return {\n      canvasWidth: 1920,\n      // Width of the canvas\n      canvasHeight: 900,\n      // Height of the canvas\n      map: [],\n      // 2D Array for the terrain\n      tank: null\n    };\n  },\n  mounted() {\n    this.initializeMap();\n    this.loadTankImage();\n  },\n  methods: {\n    loadTankImage() {\n      this.tankImage = new Image();\n      this.tankImage.src = '/assets/tank.png'; // Replace with your SVG path\n\n      // Wait for the image to load before drawing the map\n      this.tankImage.onload = () => {\n        this.drawMap(); // Draw the map after the tank image has loaded\n      };\n    },\n    // Initialize the map with ground and sky\n    initializeMap() {\n      const groundLevel = 550; // Set ground level in pixels\n\n      // Create a 2D array (matrix) representing the map\n      this.map = Array(this.canvasHeight).fill().map((_, y) => Array(this.canvasWidth).fill().map(() => y >= groundLevel ? 1 : 0));\n    },\n    // Draw the map using canvas\n    drawMap() {\n      const canvas = document.getElementById('gameCanvas');\n      const ctx = canvas.getContext('2d');\n\n      // Loop through the map array and draw each pixel\n      for (let y = 0; y < this.map.length; y++) {\n        for (let x = 0; x < this.map[y].length; x++) {\n          ctx.fillStyle = this.map[y][x] === 1 ? 'green' : 'skyblue'; // Set color based on terrain\n          ctx.fillRect(x, y, 1, 1); // Draw each pixel/block\n        }\n      }\n      const tankX = 100; // X position on the canvas\n      const tankY = 510; // Y position on the canvas\n      ctx.drawImage(this.tankImage, tankX, tankY, 50, 30); // Adjust width and height as needed\n    }\n  }\n};","map":{"version":3,"names":["name","data","canvasWidth","canvasHeight","map","tank","mounted","initializeMap","loadTankImage","methods","tankImage","Image","src","onload","drawMap","groundLevel","Array","fill","_","y","canvas","document","getElementById","ctx","getContext","length","x","fillStyle","fillRect","tankX","tankY","drawImage"],"sources":["/home/antiphy/ITU/ITU_project/src/views/GameScreen.vue"],"sourcesContent":["<template>\n\n    <div class=\"flex justify-center items-center min-h-screen bg-grey-300\">\n        <div style=\"margin-top: 180px;\">\n            <canvas id=\"gameCanvas\" :width=\"canvasWidth\" :height=\"canvasHeight\" class=\"flex justify-end\"></canvas>\n        </div>\n    </div>\n\n\n  </template>\n  \n  <script>\n  export default {\n    name: 'GameScreen',\n    data() {\n      return {\n        canvasWidth: 1920,  // Width of the canvas\n        canvasHeight: 900, // Height of the canvas\n        map: [], // 2D Array for the terrain\n        tank: null\n      };\n    },\n    mounted() {\n        this.initializeMap();\n        this.loadTankImage();\n    },\n    methods: {\n        loadTankImage() {\n            this.tankImage = new Image();\n            this.tankImage.src = '/assets/tank.png'; // Replace with your SVG path\n\n            // Wait for the image to load before drawing the map\n            this.tankImage.onload = () => {\n                this.drawMap(); // Draw the map after the tank image has loaded\n            };\n        },\n\n        // Initialize the map with ground and sky\n        initializeMap() {\n            const groundLevel = 550; // Set ground level in pixels\n            \n            // Create a 2D array (matrix) representing the map\n            this.map = Array(this.canvasHeight).fill().map((_, y) => \n                Array(this.canvasWidth).fill().map(() => (y >= groundLevel ? 1 : 0))\n            );\n        },\n\n\n    // Draw the map using canvas\n        drawMap() {\n            const canvas = document.getElementById('gameCanvas');\n            const ctx = canvas.getContext('2d');\n            \n            // Loop through the map array and draw each pixel\n            for (let y = 0; y < this.map.length; y++) {\n                for (let x = 0; x < this.map[y].length; x++) {\n                    ctx.fillStyle = this.map[y][x] === 1 ? 'green': 'skyblue'; // Set color based on terrain\n                    ctx.fillRect(x, y, 1, 1); // Draw each pixel/block\n                }\n            }\n\n            const tankX = 100; // X position on the canvas\n            const tankY = 510; // Y position on the canvas\n            ctx.drawImage(this.tankImage, tankX, tankY, 50, 30); // Adjust width and height as needed\n        },\n    }\n  };\n  </script>\n  \n  <style scoped>\n\n    .row {\n    display: flex;\n    }\n\n    .pixel {\n    width: 10px;\n    height: 10px;\n    }\n</style>"],"mappings":"AAYE,eAAe;EACbA,IAAI,EAAE,YAAY;EAClBC,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,WAAW,EAAE,IAAI;MAAG;MACpBC,YAAY,EAAE,GAAG;MAAE;MACnBC,GAAG,EAAE,EAAE;MAAE;MACTC,IAAI,EAAE;IACR,CAAC;EACH,CAAC;EACDC,OAAOA,CAAA,EAAG;IACN,IAAI,CAACC,aAAa,CAAC,CAAC;IACpB,IAAI,CAACC,aAAa,CAAC,CAAC;EACxB,CAAC;EACDC,OAAO,EAAE;IACLD,aAAaA,CAAA,EAAG;MACZ,IAAI,CAACE,SAAQ,GAAI,IAAIC,KAAK,CAAC,CAAC;MAC5B,IAAI,CAACD,SAAS,CAACE,GAAE,GAAI,kBAAkB,EAAE;;MAEzC;MACA,IAAI,CAACF,SAAS,CAACG,MAAK,GAAI,MAAM;QAC1B,IAAI,CAACC,OAAO,CAAC,CAAC,EAAE;MACpB,CAAC;IACL,CAAC;IAED;IACAP,aAAaA,CAAA,EAAG;MACZ,MAAMQ,WAAU,GAAI,GAAG,EAAE;;MAEzB;MACA,IAAI,CAACX,GAAE,GAAIY,KAAK,CAAC,IAAI,CAACb,YAAY,CAAC,CAACc,IAAI,CAAC,CAAC,CAACb,GAAG,CAAC,CAACc,CAAC,EAAEC,CAAC,KAChDH,KAAK,CAAC,IAAI,CAACd,WAAW,CAAC,CAACe,IAAI,CAAC,CAAC,CAACb,GAAG,CAAC,MAAOe,CAAA,IAAKJ,WAAU,GAAI,IAAI,CAAE,CACvE,CAAC;IACL,CAAC;IAGL;IACID,OAAOA,CAAA,EAAG;MACN,MAAMM,MAAK,GAAIC,QAAQ,CAACC,cAAc,CAAC,YAAY,CAAC;MACpD,MAAMC,GAAE,GAAIH,MAAM,CAACI,UAAU,CAAC,IAAI,CAAC;;MAEnC;MACA,KAAK,IAAIL,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,IAAI,CAACf,GAAG,CAACqB,MAAM,EAAEN,CAAC,EAAE,EAAE;QACtC,KAAK,IAAIO,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,IAAI,CAACtB,GAAG,CAACe,CAAC,CAAC,CAACM,MAAM,EAAEC,CAAC,EAAE,EAAE;UACzCH,GAAG,CAACI,SAAQ,GAAI,IAAI,CAACvB,GAAG,CAACe,CAAC,CAAC,CAACO,CAAC,MAAM,IAAI,OAAO,GAAE,SAAS,EAAE;UAC3DH,GAAG,CAACK,QAAQ,CAACF,CAAC,EAAEP,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;QAC9B;MACJ;MAEA,MAAMU,KAAI,GAAI,GAAG,EAAE;MACnB,MAAMC,KAAI,GAAI,GAAG,EAAE;MACnBP,GAAG,CAACQ,SAAS,CAAC,IAAI,CAACrB,SAAS,EAAEmB,KAAK,EAAEC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE;IACzD;EACJ;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}